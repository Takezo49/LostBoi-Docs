# Assembly Basics

### &#x20;CPU Registers (your CPUâ€™s â€œsmall variablesâ€)

Registers are **tiny storage locations inside the CPU**. Super fast compared to RAM.

Important general-purpose registers (64-bit, prefix `r`):

| Register | Purpose (common use)                              |
| -------- | ------------------------------------------------- |
| `rax`    | Main accumulator (return values, math)            |
| `rbx`    | Base register (rarely used today)                 |
| `rcx`    | Counter register (loops, `rep`)                   |
| `rdx`    | Data register (extra operand, I/O)                |
| `rsi`    | Source index (memory copy)                        |
| `rdi`    | Destination index (memory copy, function 1st arg) |
| `rsp`    | Stack pointer (top of stack)                      |
| `rbp`    | Base pointer (stack frame)                        |
| `rip`    | Instruction pointer (next instruction)            |

## ðŸ“ Assembly Instructions Cheat Sheet (Intel Syntax)

***

### 1ï¸âƒ£ `mov` â€“ Move / Copy Data

* Copies data from **source â†’ destination**.
* Does not modify the source.

```asm
mov rax, 5        ; rax = 5
mov rbx, rax      ; rbx = 5 (copied from rax)
mov rax, [var]    ; rax = value at memory address "var"
mov [var], rax    ; store rax into memory "var"
```

***

### 2ï¸âƒ£ `push` and `pop` â€“ Stack Operations

* `push` â†’ put data on stack (rsp decreases).
* `pop` â†’ take data from stack (rsp increases).

```asm
push rax          ; stack top = rax, rsp -= 8
pop rbx           ; rbx = stack top, rsp += 8
```

ðŸ“Œ Used for saving registers before function calls.

***

### 3ï¸âƒ£ `sub` and `add` â€“ Arithmetic

* Simple math with registers/memory.

```asm
add rax, rbx      ; rax = rax + rbx
sub rsp, 16       ; make space for locals on stack
```

***

### 4ï¸âƒ£ `lea` â€“ Load Effective Address

* Loads the **address** of something, not the value.
* Often used for pointer math.

```asm
lea rax, [rbx+4]  ; rax = address (rbx + 4)
lea rsi, [msg]    ; rsi = address of "msg"
```

ðŸ“Œ Think of `lea` as â€œcalculate address, donâ€™t fetch valueâ€.

***

### 5ï¸âƒ£ `cmp` â€“ Compare

* Performs subtraction **(dest - src)** but only updates FLAGS (no result stored).
* Used before conditional jumps.

```asm
cmp rax, 5        ; compare rax vs 5
; sets flags: Zero, Greater, Less...
```

***

### 6ï¸âƒ£ Jumps â€“ Control Flow

* After `cmp`, the CPU decides using flags.

| Instruction | Meaning                       |
| ----------- | ----------------------------- |
| `jmp label` | Always jump                   |
| `je label`  | Jump if equal (==)            |
| `jne label` | Jump if not equal (!=)        |
| `jg label`  | Jump if greater (>)           |
| `jge label` | Jump if greater or equal (>=) |
| `jl label`  | Jump if less (<)              |
| `jle label` | Jump if less or equal (<=)    |

Example:

```asm
cmp rax, 10
jle small_or_equal
```

***

### 7ï¸âƒ£ `call` and `ret` â€“ Functions

* `call` â†’ pushes return address on stack + jumps to function.
* `ret` â†’ pops return address from stack + jumps back.

```asm
call my_func      ; jump to function
...
my_func:
    ; function body
    ret           ; go back
```

***

### 8ï¸âƒ£ `leave` â€“ Clean up Stack Frame

Shortcut for:

```asm
mov rsp, rbp   ; reset stack pointer
pop rbp        ; restore old base pointer
```

ðŸ“Œ Used at the end of functions before `ret`.

***

### 9ï¸âƒ£ Other Useful Instructions

*   `xor reg, reg` â†’ Fast way to set register to zero.

    ```asm
    xor rax, rax   ; rax = 0
    ```
*   `inc reg` / `dec reg` â†’ Increment / decrement by 1.

    ```asm
    inc rax        ; rax = rax + 1
    dec rbx        ; rbx = rbx - 1
    ```
* `nop` â†’ No operation (do nothing, just waste a cycle).
* `syscall` â†’ Enter kernel (Linux system call).

***

## ðŸ”¹ Mini Example Putting It Together

```asm
my_func:
    push rbp            ; save base pointer
    mov rbp, rsp        ; set new base pointer
    sub rsp, 16         ; reserve 16 bytes for locals

    mov rax, 5
    cmp rax, 10
    jle less_or_equal

    mov rax, 100
    jmp end_func

less_or_equal:
    mov rax, 200

end_func:
    leave               ; restore stack
    ret                 ; return to caller
```

***

âœ… Now you know what each instruction does and how they fit into a function.
