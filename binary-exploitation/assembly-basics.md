# Assembly Basics

### &#x20;CPU Registers (your CPU’s “small variables”)

Registers are **tiny storage locations inside the CPU**. Super fast compared to RAM.

Important general-purpose registers (64-bit, prefix `r`):

| Register | Purpose (common use)                              |
| -------- | ------------------------------------------------- |
| `rax`    | Main accumulator (return values, math)            |
| `rbx`    | Base register (rarely used today)                 |
| `rcx`    | Counter register (loops, `rep`)                   |
| `rdx`    | Data register (extra operand, I/O)                |
| `rsi`    | Source index (memory copy)                        |
| `rdi`    | Destination index (memory copy, function 1st arg) |
| `rsp`    | Stack pointer (top of stack)                      |
| `rbp`    | Base pointer (stack frame)                        |
| `rip`    | Instruction pointer (next instruction)            |

## 📝 Assembly Instructions Cheat Sheet (Intel Syntax)

***

### 1️⃣ `mov` – Move / Copy Data

* Copies data from **source → destination**.
* Does not modify the source.

```asm
mov rax, 5        ; rax = 5
mov rbx, rax      ; rbx = 5 (copied from rax)
mov rax, [var]    ; rax = value at memory address "var"
mov [var], rax    ; store rax into memory "var"
```

***

### 2️⃣ `push` and `pop` – Stack Operations

* `push` → put data on stack (rsp decreases).
* `pop` → take data from stack (rsp increases).

```asm
push rax          ; stack top = rax, rsp -= 8
pop rbx           ; rbx = stack top, rsp += 8
```

📌 Used for saving registers before function calls.

***

### 3️⃣ `sub` and `add` – Arithmetic

* Simple math with registers/memory.

```asm
add rax, rbx      ; rax = rax + rbx
sub rsp, 16       ; make space for locals on stack
```

***

### 4️⃣ `lea` – Load Effective Address

* Loads the **address** of something, not the value.
* Often used for pointer math.

```asm
lea rax, [rbx+4]  ; rax = address (rbx + 4)
lea rsi, [msg]    ; rsi = address of "msg"
```

📌 Think of `lea` as “calculate address, don’t fetch value”.

***

### 5️⃣ `cmp` – Compare

* Performs subtraction **(dest - src)** but only updates FLAGS (no result stored).
* Used before conditional jumps.

```asm
cmp rax, 5        ; compare rax vs 5
; sets flags: Zero, Greater, Less...
```

***

### 6️⃣ Jumps – Control Flow

* After `cmp`, the CPU decides using flags.

| Instruction | Meaning                       |
| ----------- | ----------------------------- |
| `jmp label` | Always jump                   |
| `je label`  | Jump if equal (==)            |
| `jne label` | Jump if not equal (!=)        |
| `jg label`  | Jump if greater (>)           |
| `jge label` | Jump if greater or equal (>=) |
| `jl label`  | Jump if less (<)              |
| `jle label` | Jump if less or equal (<=)    |

Example:

```asm
cmp rax, 10
jle small_or_equal
```

***

### 7️⃣ `call` and `ret` – Functions

* `call` → pushes return address on stack + jumps to function.
* `ret` → pops return address from stack + jumps back.

```asm
call my_func      ; jump to function
...
my_func:
    ; function body
    ret           ; go back
```

***

### 8️⃣ `leave` – Clean up Stack Frame

Shortcut for:

```asm
mov rsp, rbp   ; reset stack pointer
pop rbp        ; restore old base pointer
```

📌 Used at the end of functions before `ret`.

***

### 9️⃣ Other Useful Instructions

*   `xor reg, reg` → Fast way to set register to zero.

    ```asm
    xor rax, rax   ; rax = 0
    ```
*   `inc reg` / `dec reg` → Increment / decrement by 1.

    ```asm
    inc rax        ; rax = rax + 1
    dec rbx        ; rbx = rbx - 1
    ```
* `nop` → No operation (do nothing, just waste a cycle).
* `syscall` → Enter kernel (Linux system call).

***

## 🔹 Mini Example Putting It Together

```asm
my_func:
    push rbp            ; save base pointer
    mov rbp, rsp        ; set new base pointer
    sub rsp, 16         ; reserve 16 bytes for locals

    mov rax, 5
    cmp rax, 10
    jle less_or_equal

    mov rax, 100
    jmp end_func

less_or_equal:
    mov rax, 200

end_func:
    leave               ; restore stack
    ret                 ; return to caller
```

***

✅ Now you know what each instruction does and how they fit into a function.
